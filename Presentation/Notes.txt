För att uppnå kravet för väl godkänt krävs även följande:
Du ska göra ytterligare en applikation, som ska vara en grafisk applikation (WPF/MAUI).
* Det ska gå att navigera sig mellan två vyer. Ena vyn ska vara själva listan och den andra vyn ska vara en vy där du kan skapa och visa en produkt (du får ha dessa på två separata vyer om du så vill).
Produkten ska även innehålla värden som kategori och tillverkare. Dessa ska då vara separata klasser.
Du måste implementera interfaces.
Du måste använda dig av Service Pattern och separera ansvarsområden.
Utöver funktionalitet såsom att lägga till och visa alla produkter ska det nu även gå att uppdatera produktinformationen samt ta bort en produkt från listan. 
Du ska även se till att en produkt inte kan läggas till två gånger eller att en tom produkt kan läggas till.
* Du ska skapa enhetstester som testar alla dina funktioner som du har skapat.
Lägg till en kontroll i funktionen som lägger till en produkt för att säkerställa att produkter med samma namn inte kan läggas till två gånger.
Produktinformationen ska sparas ner till en .json-fil och ska även kunna hämtas upp när programmet startar och när ny lista ska hämtas.
* Du måste göra enhetstester/integrationstester för samtlig funktionalitet såsom att lägga till, visa, uppdatera, ta bort, läsa in lista, spara lista.
Du måste använda dig av Git/GitHub och använda dig av olika branches när du skapar din funktionalitet. Dina branches i GitHub får inte tas bort utan ska finnas kvar. Men den slutgiltiga inlämningen ska vara main/master-branchen.

---------------------------------------------------------------------------------

Element (också kallat kontroll): window, grid, button, slider, textbox etc.
På Window-elementet finns olika attribut: title, xmlns, x:Class, source (src)

public async Task<ProductServiceResult<Product>> SaveProductAsync(Product product) // MÅSTE FÅNGA UPP DATA = NULL I MAINWINDOW.XAML.CS


---------------------------------------------------------------
Branchen: 
Cancellation handling ProductListViewModel: 
- Add LoadCommand.Execute(null). Automaticcaly load the list on startup
- Add catch (OperationCanceledException) to LoadAsync, to adress user 
- Add RefreshAsync-method to ProductListViewModel to separate load and reload-command
- Add HideStatusSoon to handle statusmeddelanden
- Add Ladda om/Avbryt-button incomplete






- Remove _cts field and Cancel() method from ProductService - cancel-call is not made from productservice
- Update design so ProductListViewModel owns CancellationTokenSource 
- Update IProductService methods to accept CancellationToken ct = default
- Centralize OperationCanceledException handling in EnsureLoadedAsync - catch(Operation-canceledException) 
- Remove redundant try-catch from GetProductsAsync

fix(ProductService.Helpers): add if-else-statement to UpdateCategoryAsync and UpdateManufacturerAsync to be able to remove already assigned value

flyttar cancel-logiken toll viewmodel och tar bort cancel-metod i productservice

avoid boilerplate with asyncrelaycommand in viewmodel (alltså tar bort upprepning av cts i alla metoder)




feat: add FormViewModelBase to minimera upprepad kod

feat: – när du lägger till en ny funktionalitet
fix: – när du rättar ett fel
refactor: – när du omstrukturerar utan ny funktion
docs: – när du ändrar dokumentation
test: – när du lägger till eller ändrar tester

CANCELLATIONTOKEN ATT GÖRA:
1. ändra interface med CancellationToken ct = default
2. Uppdatera Delete/Update/Save/Get with CancellationToken ct = default. EnsureLoaded with ct centralize ... 
3 ta bort Cancel-method och _cts från productservice
4. add AsyncRelayCommand to productlistviewmodel, som injicerar en token i execute-metoden och avbryt via dess CancelCommand.
5. Bind loadcommand and refreshcomman do execute-method LoadAsync
6. add cNCE-BUTTON

Byt avbryt-knapp till tillbaka

Default-token (CancellationToken ct = default): Trycker användaren inte på Cancel-knappen blir ct -> default(CancellationToken), 
vilket innebär att ct.IsCancellationRequested alltid är false.

AsyncRelayCommand injicerar automatiskt en token i execute-metoden LoadAsync.
Effekten:


 <!-- Spara-knapp -->
<Button Content="Spara" Command="{Binding SaveCommand}" />

<!-- Avbryt pågående Save (cancellation), inte navigationen -->
<Button Content="Avbryt sparande" Command="{Binding SaveCommand.CancelCommand}" />

<!-- Navigerings-avbryt (tillbaka till listan) -->
<Button Content="Tillbaka" Command="{Binding CancelCommand}" />

AsyncRelayCommand skapar och äger CTS internt och sköter Cancel() och Dispose() åt dig.

----------------------------------------------------------------------


CommunityToolkit AsyncRelayCommand med signaturen Task LoadAsync(CancellationToken ct), injicerar kommandot en token automatiskt när du anropar new AsyncRelayCommand(LoadAsync).

Refactor CancellationToken:
.NET-standard: den som startar operationen äger avbryt, alltså användaren av applikationen ex. en Avbryt-knapp i UI. 

Eftersom EnsureLoadedAsync är den metod i ProductService som alltid först pratar med repot för att läsa från fil (via anrop till GetProductsAsync), så är den satt att hantera OperationCanceledException i och med att inparametern ct inte är satt som default / behöver den stöd för avbryt (luddigt, förtydliga kort och koncist).
De andra metoderna tar ct som inparameter för att kunna vidarebefodra ett cancel-command (token) till EnsureLoaded som sedan avbryter den pågående operationen.



ATT GÖRA:
--------------
Ta tag i cancellationtoken och cancel ändringar
bryt ut och skapa hjälpmetoder för att korta ned metoder

Skapa en FormViewModelBase - cancel och save-metoderna-duplicering.. ärver
Skapa en StatusViewModelBase alla tre metoder plocka bor statusmeddelanden efter ett tag..ärver

Enhetstester xUnit 
(integrationstest Repository??)






DDD (Domain-Driven Design)
--------------------------
Domänen:      Produkthantering (området programmet handlar om)
Entities:     Product, Category, Manufacturer. Även kallat domänens kärnmodeller. Har alltid en unik Id-property, vilket är det som gör dem till entities.
DTOs:         ProductUpdateRequest, ProductRequest (Data Transfer Object - används bara för att flytta data mellan lager, ex. UI -> ProductService)
Repositories: ProductRepository, CategoryRepository, ManufacturerRepository
Service:      ProductService (samordnar logiken)

Domain =		 Entities och Interfaces (vad systemet är). Kataloger: Project Reference: None
Application =	 Use cases och affärslogik (vad systemet gör). Project Reference: Domain
Infrastructure = Repositories och teknik (hur systemet lagrar data). Project Reference: Domain
Presentation =	 UI/MVVM (hur användaren interagerar). Project Reference: Domain (Composition Root - DI-container)




xUnit:
kopiera interface + metoder i productservice. samma med fileservice och Ifileservice - detta ska testas
extensionmethods + helpers men inte readasync i filerepository
// helpers, extensionmethods testas, id visas i listvyn eller editvyn


Repository: tekniskt skydd (filåtkomst, skrivfel)

Service: affärslogiskt skydd (t.ex. “produkt finns redan”)

ViewModel: användarskydd (UI’t kraschar inte)


---------------------------------------------------
CancellationTokenändring i presentation:
Vad är LoadCommand.Execute(null)? 
Det startar ditt AsyncRelayCommand direkt vid uppstart. Fördelen: kommandot skapar en intern CancellationTokenSource, sätter IsRunning och exponerar CancelCommand så att du kan avbryta just den körningen. Om du i stället kör _ = LoadAsync() i konstruktorn går laddningen utanför kommandot och kan inte avbrytas via CancelCommand.

(autoladda, men via kommandot så att Cancel fungerar på första laddningen.).